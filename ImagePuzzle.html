<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Puzzle Slider</title>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                fontFamily: {
                    sans: ['Inter', 'sans-serif'],
                    heading: ['Outfit', 'sans-serif'],
                },
                extend: {
                    colors: {
                        primary: '#6c5ce7',
                        secondary: '#a29bfe',
                        accent: '#fd79a8',
                        dark: '#1e202a',
                        surface: '#2b2e3b',
                        success: '#00b894',
                        warning: '#fdcb6e',
                    },
                    animation: {
                        'pop': 'pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                    },
                    keyframes: {
                        pop: {
                            '0%': { transform: 'scale(0.8)', opacity: '0' },
                            '100%': { transform: 'scale(1)', opacity: '1' },
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .tile {
            transition: transform 0.2s ease-in-out;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.2), 0 4px 6px rgba(0,0,0,0.3);
        }
        .tile:hover {
            z-index: 10;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.5), 0 8px 12px rgba(0,0,0,0.5);
        }
        /* Hide scrollbar for gallery */
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
    </style>
</head>
<body class="bg-[#13151b] text-white min-h-screen flex flex-col items-center p-4 font-sans overflow-x-hidden selection:bg-primary selection:text-white">

    <div class="w-full max-w-6xl flex flex-col items-center">
        
        <!-- Header -->
        <header class="text-center w-full mb-6 relative z-10 flex flex-col md:flex-row items-center justify-between gap-4">
            <div class="text-left">
                <h1 class="text-3xl md:text-4xl font-black font-heading bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-cyan-400 drop-shadow-sm">
                    IMAGE SLIDER
                </h1>
                <p class="text-gray-400 text-sm">Reconstruct the image by sliding tiles</p>
            </div>

            <div class="flex items-center gap-3">
                <a href="index.html" class="px-4 py-2 rounded-xl bg-white/5 hover:bg-white/10 text-sm font-bold border border-white/10 transition-colors flex items-center gap-2">
                    <i class="fas fa-home"></i> Hub
                </a>
                <button id="sound-toggle" class="px-4 py-2 rounded-xl bg-white/5 hover:bg-white/10 text-sm font-bold border border-white/10 transition-colors" title="Toggle Sound">
                    <i class="fas fa-volume-up"></i>
                </button>
            </div>
        </header>

        <div class="w-full grid grid-cols-1 lg:grid-cols-12 gap-8 items-start">
            
            <!-- Left Sidebar: Controls & Stats -->
            <div class="lg:col-span-4 xl:col-span-3 w-full flex flex-col gap-4 order-2 lg:order-1">
                
                <!-- Stats Box -->
                <div class="bg-surface/30 backdrop-blur-xl rounded-2xl p-5 border border-white/5 shadow-xl">
                    <div class="grid grid-cols-2 gap-4">
                        <div class="text-center p-3 bg-black/20 rounded-xl">
                            <i class="fas fa-stopwatch text-blue-400 mb-1"></i>
                            <div class="text-xs text-gray-400 uppercase font-bold tracking-wider">Time</div>
                            <div id="timer" class="text-xl font-bold text-white font-heading">00:00</div>
                        </div>
                        <div class="text-center p-3 bg-black/20 rounded-xl">
                            <i class="fas fa-shoe-prints text-green-400 mb-1"></i>
                            <div class="text-xs text-gray-400 uppercase font-bold tracking-wider">Moves</div>
                            <div id="move-counter" class="text-xl font-bold text-white font-heading">0</div>
                        </div>
                    </div>
                </div>

                <!-- Difficulty -->
                <div class="bg-surface/30 backdrop-blur-xl rounded-2xl p-5 border border-white/5 shadow-xl">
                    <h3 class="text-sm font-bold text-gray-300 mb-3 uppercase tracking-wide">Difficulty</h3>
                    <div class="grid grid-cols-1 gap-2">
                        <button class="diff-btn active px-4 py-3 rounded-xl text-sm font-bold bg-primary text-white shadow-lg shadow-primary/20 transition-all hover:scale-102 flex items-center justify-between group" data-size="3">
                            <span>Easy (3x3)</span>
                            <span class="opacity-100 group-[.active]:opacity-100"><i class="fas fa-check"></i></span>
                        </button>
                        <button class="diff-btn px-4 py-3 rounded-xl text-sm font-bold bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white transition-all hover:scale-102 flex items-center justify-between group" data-size="4">
                            <span>Medium (4x4)</span>
                            <span class="opacity-0 group-[.active]:opacity-100"><i class="fas fa-check"></i></span>
                        </button>
                        <button class="diff-btn px-4 py-3 rounded-xl text-sm font-bold bg-white/5 text-gray-400 hover:bg-white/10 hover:text-white transition-all hover:scale-102 flex items-center justify-between group" data-size="5">
                            <span>Hard (5x5)</span>
                            <span class="opacity-0 group-[.active]:opacity-100"><i class="fas fa-check"></i></span>
                        </button>
                    </div>
                </div>

                <!-- Image Selector (Small preview list) -->
                 <div class="bg-surface/30 backdrop-blur-xl rounded-2xl p-5 border border-white/5 shadow-xl">
                    <h3 class="text-sm font-bold text-gray-300 mb-3 uppercase tracking-wide">Select Image</h3>
                    <div class="flex lg:grid lg:grid-cols-3 gap-2 overflow-x-auto lg:overflow-visible hide-scrollbar pb-2 lg:pb-0" id="image-gallery">
                        <!-- Injected via JS -->
                    </div>
                </div>

                <!-- Preview Toggle -->
                <button id="preview-btn" class="w-full py-3 bg-white/10 hover:bg-white/20 rounded-xl font-bold text-white transition-colors border border-white/5 flex items-center justify-center gap-2 select-none active:scale-95">
                    <i class="fas fa-eye"></i> Hold to Preview
                </button>

            </div>

            <!-- Center: Game Board -->
            <div class="lg:col-span-8 xl:col-span-9 w-full flex flex-col items-center order-1 lg:order-2">
                <div class="w-full max-w-[600px] relative p-1 md:p-4 bg-surface/30 backdrop-blur-xl rounded-3xl border border-white/5 shadow-2xl">
                    
                    <!-- The Puzzle Container -->
                    <!-- Added min-h to prevent collapse -->
                    <div id="puzzle-container" class="relative bg-black/50 rounded-xl overflow-hidden shadow-inner cursor-pointer w-full aspect-square min-h-[300px] md:min-h-[500px]">
                        <!-- Tiles injected here -->
                    </div>

                    <!-- Overlay for solved state -->
                    <div id="game-overlay" class="absolute inset-0 z-20 bg-black/85 backdrop-blur-md rounded-3xl flex flex-col items-center justify-center hidden opacity-0 transition-opacity duration-300">
                        <div class="text-center p-6 animate-pop">
                            <div class="text-6xl mb-4">ðŸŽ‰</div>
                            <h2 class="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500 mb-2 font-heading">
                                PUZZLE SOLVED!
                            </h2>
                            <p class="text-gray-300 mb-6" id="final-stats">Time: 00:00 â€¢ Moves: 0</p>
                            <button id="play-again-btn" class="px-8 py-3 bg-gradient-to-r from-primary to-secondary rounded-xl font-bold text-white shadow-lg shadow-primary/30 hover:scale-105 transition-transform">
                                Play Again
                            </button>
                        </div>
                    </div>
                    
                    <!-- Full Image Overlay (Preview) -->
                     <div id="preview-overlay" class="absolute inset-0 z-30 pointer-events-none opacity-0 transition-opacity duration-200 p-1 md:p-4 rounded-3xl flex flex-col items-center justify-center bg-black/50 backdrop-blur-sm">
                        <div class="w-full h-full rounded-xl overflow-hidden relative shadow-2xl">
                             <img id="preview-image-full" src="" class="w-full h-full object-cover" alt="Preview">
                             <div class="absolute inset-x-0 bottom-0 bg-black/70 backdrop-blur-md p-3 text-center text-white font-bold tracking-wide uppercase text-sm border-t border-white/10">Original Image</div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- Background decoration -->
    <div class="fixed top-0 left-0 w-full h-full pointer-events-none -z-10">
        <div class="absolute top-[10%] right-[20%] w-[600px] h-[600px] bg-blue-600/10 rounded-full blur-[120px]"></div>
        <div class="absolute bottom-[10%] left-[10%] w-[500px] h-[500px] bg-cyan-600/10 rounded-full blur-[120px]"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Configuration
            const images = [
                'https://images.unsplash.com/photo-1682687220742-aba13b6e50ba?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80', // Mountains
                'https://images.unsplash.com/photo-1546527868-ccb7ee7dfa6a?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80', // Puppy
                'https://images.unsplash.com/photo-1534447677768-be436bb09401?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80', // City
                'https://images.unsplash.com/photo-1565299624946-b28f40a0ae38?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80', // Pizza
                'https://images.unsplash.com/photo-1451187580459-43490279c0fa?ixlib=rb-4.0.3&auto=format&fit=crop&w=1000&q=80', // Space
            ];

            let state = {
                gridSize: 3, // 3x3
                currentImage: images[0],
                tiles: [], // {index: 0, currentPos: 0}
                emptyPos: 8, // Last position index (gridSize*gridSize - 1)
                moves: 0,
                time: 0,
                timerInterval: null,
                isPlaying: false,
                isSolved: false,
                soundEnabled: true
            };

            // DOM Elements
            const puzzleContainer = document.getElementById('puzzle-container');
            const timerEl = document.getElementById('timer');
            const movesEl = document.getElementById('move-counter');
            const gameOverlay = document.getElementById('game-overlay');
            const finalStatsEl = document.getElementById('final-stats');
            const diffButtons = document.querySelectorAll('.diff-btn');
            const playAgainBtn = document.getElementById('play-again-btn');
            const imageGallery = document.getElementById('image-gallery');
            const previewBtn = document.getElementById('preview-btn');
            const previewOverlay = document.getElementById('preview-overlay');
            const previewImageFull = document.getElementById('preview-image-full');
            const soundToggle = document.getElementById('sound-toggle');

            // Audio Context
            let audioCtx;
            
            function initAudio() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            }

            function playSound(type) {
                if (!state.soundEnabled) return;
                initAudio();

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                
                const now = audioCtx.currentTime;

                if (type === 'slide') {
                    // Quick warm thud
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(200, now);
                    osc.frequency.linearRampToValueAtTime(100, now + 0.1);
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.linearRampToValueAtTime(0, now + 0.1);
                    osc.start(now);
                    osc.stop(now + 0.1);
                } else if (type === 'win') {
                    // Victory chime
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const o = audioCtx.createOscillator();
                        const g = audioCtx.createGain();
                        o.connect(g);
                        g.connect(audioCtx.destination);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.05, now + i * 0.15);
                        g.gain.linearRampToValueAtTime(0, now + i * 0.15 + 1.0);
                        o.start(now + i * 0.15);
                        o.stop(now + i * 0.15 + 1.0);
                    });
                }
            }

            // Initialize Gallery
            images.forEach((src, idx) => {
                const thumb = document.createElement('div');
                thumb.className = `w-full aspect-square bg-cover bg-center rounded-lg overflow-hidden cursor-pointer border-2 transition-all ${idx === 0 ? 'border-primary opacity-100 ring-2 ring-primary/50' : 'border-transparent opacity-60 hover:opacity-100'}`;
                thumb.style.backgroundImage = `url('${src}')`;
                thumb.onclick = () => selectImage(src, thumb);
                imageGallery.appendChild(thumb);
            });

            function selectImage(src, thumbEl) {
                state.currentImage = src;
                // Update active state in UI
                Array.from(imageGallery.children).forEach(c => {
                    c.className = 'w-full aspect-square bg-cover bg-center rounded-lg overflow-hidden cursor-pointer border-2 border-transparent opacity-60 hover:opacity-100 transition-all';
                });
                thumbEl.className = 'w-full aspect-square bg-cover bg-center rounded-lg overflow-hidden cursor-pointer border-2 border-primary opacity-100 ring-2 ring-primary/50 transition-all';
                restartGame();
            }

            // Logic: Create Tile Grid
            function createTiles() {
                puzzleContainer.innerHTML = '';
                state.tiles = [];
                const totalTiles = state.gridSize * state.gridSize;
                const tileSizePct = 100 / state.gridSize;

                // Create tiles 0 to N-2. N-1 is empty.
                for (let i = 0; i < totalTiles; i++) {
                    if (i === totalTiles - 1) {
                         // Empty tile logic
                         state.emptyPos = i;
                         state.tiles.push({ index: null, currentPos: i }); // Empty
                         continue;
                    }

                    const tile = document.createElement('div');
                    tile.id = `tile-${i}`;
                    tile.className = 'tile absolute cursor-pointer bg-surface overflow-hidden rounded-lg border border-white/10';
                    tile.style.width = `calc(${tileSizePct}% - 2px)`; // Margins included
                    tile.style.height = `calc(${tileSizePct}% - 2px)`;
                    
                    // Positioning
                    // Use CSS vars or inline styles dynamically
                    tile.style.top = `${Math.floor(i / state.gridSize) * tileSizePct}%`;
                    tile.style.left = `${(i % state.gridSize) * tileSizePct}%`;
                    tile.style.margin = '1px'; // Physical gap
                    
                    // Background Image Logic
                    const row = Math.floor(i / state.gridSize);
                    const col = i % state.gridSize;
                    
                    tile.style.backgroundImage = `url('${state.currentImage}')`;
                    tile.style.backgroundSize = `${state.gridSize * 100}%`;
                    tile.style.backgroundPosition = `${(col / (state.gridSize - 1)) * 100}% ${(row / (state.gridSize - 1)) * 100}%`;

                    // Interaction
                    tile.onclick = () => handleTileClick(i);

                    // Store internal state
                    state.tiles.push({ index: i, currentPos: i, element: tile });
                    puzzleContainer.appendChild(tile);
                }

                // Shuffle
                setTimeout(shuffleBoard, 100); // Slight delay for rendering
            }

            function shuffleBoard() {
                // To ensure solvability, we simulate valid random moves from the solved state
                let moves = 0;
                const totalMoves = state.gridSize * 25; // Good randomness
                const maxIndex = state.gridSize * state.gridSize - 1;
                
                let lastMove = -1;

                while (moves < totalMoves) {
                    const neighbors = getNeighbors(state.emptyPos);
                    // Filter out returning to last move to encourage entropy
                    const validMoves = neighbors.filter(pos => pos !== lastMove);
                    
                    // Fallback if cornered (rare/impossible in 2+ neighbors logic, but safecheck)
                    const moveOptions = validMoves.length > 0 ? validMoves : neighbors;
                    const randomMove = moveOptions[Math.floor(Math.random() * moveOptions.length)];
                    
                    // Find which tile is at this position
                    const tileObj = state.tiles.find(t => t.currentPos === randomMove);
                    
                    if (tileObj) {
                        // Swap logic (without animation for shuffle)
                        swapPositions(tileObj, true);
                        lastMove = state.emptyPos; 
                        moves++;
                    } else {
                        console.error('Tile Not Found', randomMove);
                        break;
                    }
                }

                state.moves = 0;
                state.time = 0;
                state.isPlaying = false;
                state.isSolved = false;
                movesEl.textContent = '0';
                timerEl.textContent = '00:00';
                gameOverlay.classList.remove('opacity-100', 'flex');
                gameOverlay.classList.add('hidden', 'opacity-0');
            }

            function getNeighbors(pos) {
                const size = state.gridSize;
                const row = Math.floor(pos / size);
                const col = pos % size;
                const neighbors = [];

                if (row > 0) neighbors.push(pos - size); // Up
                if (row < size - 1) neighbors.push(pos + size); // Down
                if (col > 0) neighbors.push(pos - 1); // Left
                if (col < size - 1) neighbors.push(pos + 1); // Right

                return neighbors;
            }

            function handleTileClick(originalIndex) {
                 initAudio(); // Ensure context is ready
                 if (state.isSolved) return;

                 const tileObj = state.tiles.find(t => t.index === originalIndex);
                 const currentPos = tileObj.currentPos;
                 const neighbors = getNeighbors(state.emptyPos);

                 if (neighbors.includes(currentPos)) {
                     // Valid move
                     if (!state.isPlaying) startTimer();
                     swapPositions(tileObj);
                     playSound('slide');
                     state.moves++;
                     movesEl.textContent = state.moves;

                     checkWin();
                 }
            }

            function swapPositions(tileObj, instant = false) {
                const tileSizePct = 100 / state.gridSize;
                const oldPos = tileObj.currentPos;
                const newPos = state.emptyPos;

                 // Update internal state
                tileObj.currentPos = newPos;
                state.emptyPos = oldPos;
                
                // Update UI
                const newRow = Math.floor(newPos / state.gridSize);
                const newCol = newPos % state.gridSize;

                if (tileObj.element) {
                    // Update style
                    // Force transform instead of top/left for smoother 60fps? 
                    // No, Top/Left + transition is easier for this simpler grid logic without absolute transform calculations.
                    // But we must match createTiles logic.
                    
                    if (instant) {
                        tileObj.element.style.transition = 'none';
                        tileObj.element.style.top = `${newRow * tileSizePct}%`;
                        tileObj.element.style.left = `${newCol * tileSizePct}%`;
                        // Force reflow
                         tileObj.element.offsetHeight; 
                        tileObj.element.style.transition = 'top 0.2s ease-in-out, left 0.2s ease-in-out';
                    } else {
                        tileObj.element.style.transition = 'top 0.2s ease-in-out, left 0.2s ease-in-out';
                        tileObj.element.style.top = `${newRow * tileSizePct}%`;
                        tileObj.element.style.left = `${newCol * tileSizePct}%`;
                    }
                }
            }

            function checkWin() {
                const correctCount = state.tiles.filter(t => t.index !== null).filter(t => t.index === t.currentPos).length;
                if (correctCount === (state.gridSize * state.gridSize - 1)) {
                    gameWon();
                }
            }

            function gameWon() {
                state.isSolved = true;
                stopTimer();
                setTimeout(() => playSound('win'), 300); // Slight delay for satisfaction
                
                // Show completion overlay
                finalStatsEl.innerHTML = `<span class="text-white font-bold">${formatTime(state.time)}</span> <span class="mx-2">|</span> <span class="text-white font-bold">${state.moves} Moves</span>`;
                gameOverlay.classList.remove('hidden', 'opacity-0');
                gameOverlay.classList.add('flex', 'opacity-100');
            }

            // Timer Logic
            function startTimer() {
                if (state.isPlaying) return;
                state.isPlaying = true;
                clearInterval(state.timerInterval);
                state.timerInterval = setInterval(() => {
                    state.time++;
                    timerEl.textContent = formatTime(state.time);
                }, 1000);
            }

            function stopTimer() {
                state.isPlaying = false;
                clearInterval(state.timerInterval);
            }

            function formatTime(sec) {
                const m = Math.floor(sec / 60).toString().padStart(2, '0');
                const s = (sec % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            }

            // Controls logic
            function restartGame() {
                stopTimer();
                createTiles();
            }

            // Difficulty buttons
            diffButtons.forEach(btn => {
                btn.onclick = () => {
                    const size = parseInt(btn.dataset.size);
                    if (size !== state.gridSize) {
                        // Update UI Active State
                        diffButtons.forEach(b => {
                            b.classList.remove('active', 'bg-primary', 'text-white', 'shadow-lg');
                            b.classList.add('bg-white/5', 'text-gray-400');
                            b.querySelector('span:last-child').classList.remove('opacity-100');
                            b.querySelector('span:last-child').classList.add('opacity-0');
                        });
                        btn.classList.add('active', 'bg-primary', 'text-white', 'shadow-lg');
                        btn.classList.remove('bg-white/5', 'text-gray-400');
                        btn.querySelector('span:last-child').classList.add('opacity-100');
                        btn.querySelector('span:last-child').classList.remove('opacity-0');
                        
                        state.gridSize = size;
                        restartGame();
                    }
                };
            });

            playAgainBtn.onclick = restartGame;
            
            // Preview
            const events = ['mousedown', 'touchstart'];
            const endEvents = ['mouseup', 'mouseleave', 'touchend'];

            events.forEach(evt => {
                previewBtn.addEventListener(evt, (e) => {
                    if(e.cancelable) e.preventDefault();
                    previewImageFull.src = state.currentImage;
                    previewOverlay.classList.remove('opacity-0');
                });
            });
            endEvents.forEach(evt => {
                 previewBtn.addEventListener(evt, () => {
                    previewOverlay.classList.add('opacity-0');
                });
            });

            // Sound Toggle
            soundToggle.onclick = () => {
                state.soundEnabled = !state.soundEnabled;
                soundToggle.innerHTML = state.soundEnabled ? '<i class="fas fa-volume-up"></i>' : '<i class="fas fa-volume-mute"></i>';
                soundToggle.classList.toggle('text-red-400', !state.soundEnabled);
                // Initialize audio on first user click just in case
                initAudio();
            };

            // Init
            createTiles();
        });
    </script>
</body>
</html>
